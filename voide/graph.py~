# File: workspace/voide/graph.py
"""Holds nodes and edges, supports JSON serialization."""
def __init__(self) -> None:
self.nodes: Dict[str, Node] = {}
self.edges: List[Edge] = []


def add_node(self, node: Node) -> None:
if node.id in self.nodes:
raise GraphError(f"Duplicate node id: {node.id}")
self.nodes[node.id] = node


def add_edge(self, edge: Edge) -> None:
if edge.from_node not in self.nodes or edge.to_node not in self.nodes:
raise GraphError(f"Unknown node in edge: {edge}")
self.edges.append(edge)


def to_dict(self) -> Dict[str, Any]:
return {
"nodes": [vars(n) for n in self.nodes.values()],
"edges": [vars(e) for e in self.edges],
}


@classmethod
def from_dict(cls, data: Dict[str, Any]) -> Graph:
g = cls()
for nd in data.get("nodes", []):
node = Node(
id=nd["id"], type_name=nd["type_name"], config=nd.get("config", {}),
inputs={}, outputs={},
)
g.add_node(node)
for ed in data.get("edges", []):
g.add_edge(Edge(**ed))
return g


def topo_sort(self) -> List[Node]:
# Kahn's algorithm on node-level dependencies
deps: Dict[str, set[str]] = {nid: set() for nid in self.nodes}
for e in self.edges:
deps[e.to_node].add(e.from_node)
ready = [nid for nid, ds in deps.items() if not ds]
result: List[Node] = []
while ready:
nid = ready.pop(0)
result.append(self.nodes[nid])
for e in self.edges:
if e.from_node == nid:
tgt = e.to_node
deps[tgt].remove(nid)
if not deps[tgt]:
ready.append(tgt)
if len(result) != len(self.nodes):
raise CycleError("Graph has cycles or missing dependencies")
return result
